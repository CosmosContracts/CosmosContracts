package decorators

import (
	globalfeekeeper "github.com/CosmosContracts/juno/v18/x/globalfee/keeper"

	sdk "github.com/cosmos/cosmos-sdk/types"
	sdkerrors "github.com/cosmos/cosmos-sdk/types/errors"
	authante "github.com/cosmos/cosmos-sdk/x/auth/ante"
	bankkeeper "github.com/cosmos/cosmos-sdk/x/bank/keeper"
	feegrantkeeper "github.com/cosmos/cosmos-sdk/x/feegrant/keeper"

	errorsmod "cosmossdk.io/errors"
)

type MsgFeePrepayDecorator struct {
	BankKeeper bankkeeper.Keeper
	// TODO: This could be incorrect. We may need the full AuthKeeper/AccountKeeper, not just from the ante
	AccountKeeper   authante.AccountKeeper
	GlobalFeeKeeper globalfeekeeper.Keeper

	FeeGrantKeeper feegrantkeeper.Keeper
}

func NewMsgFeePrepayDecorator(bank bankkeeper.Keeper, auth authante.AccountKeeper, globalFee globalfeekeeper.Keeper) MsgFeePrepayDecorator {
	return MsgFeePrepayDecorator{
		BankKeeper:      bank,
		AccountKeeper:   auth,
		GlobalFeeKeeper: globalFee,
	}
}

// junod tx tokenfactory create-denom joel --fees=0ujuno --from=juno1 --home=/home/joel/.juno1 --chain-id=local-1 --keyring-backend=test -y --gas=2200000
func (fpd MsgFeePrepayDecorator) AnteHandle(ctx sdk.Context, tx sdk.Tx, simulate bool, next sdk.AnteHandler) (newCtx sdk.Context, err error) {

	ctx.Logger().Error("MsgFeePrepayDecorator", "Starting", true)

	// 1. Confirm the transaction is a FeeTx
	// 2. Calculate the total fee
	// 3. Transfer funds to the user (either indirectly through the bank module or directly)
	// 4. Set the new fee on the Tx
	// 5. Continue processing as normal

	// if tx is read only
	// tx := new sdk.Tx(...tx, set the new fee)

	// This may not be a FeeTx, so if error then don't exit early
	feeTx, ok := tx.(sdk.FeeTx)
	if !ok {
		return ctx, errorsmod.Wrap(sdkerrors.ErrTxDecode, "Tx must implement the sdk.FeeTx interface")
	}

	// feePrePayModuleAcc := fpd.AccountKeeper.GetModuleAddress("feeprepay")
	// fpd.FeeGrantKeeper.GrantAllowance(ctx, feePrePayModuleAcc, feeTx.FeePayer(), &feegranttypes.{})

	if ctx.BlockHeight() > 0 {

		// Global fee keeper params
		p := fpd.GlobalFeeKeeper.GetParams(ctx)

		// Get min juno gas
		var minGasPrice sdk.DecCoin
		for _, c := range p.MinimumGasPrices {
			if c.Denom == "ujuno" {
				minGasPrice = c
			}
		}

		ctx.Logger().Error("MsgFeePrepayDecorator", "MinGas", minGasPrice)
		ctx.Logger().Error("MsgFeePrepayDecorator", "FeeTx (gas)", feeTx.GetGas())
		ctx.Logger().Error("MsgFeePrepayDecorator", "Consumed Gas", ctx.GasMeter().GasConsumed())

		// Calculate gas consumed
		consumed := ctx.GasMeter().GasConsumed()

		// Determine fee by multiplying gas price by gas consumed
		fee := minGasPrice.Amount.Mul(sdk.NewDec(int64(consumed))).RoundInt()

		ctx.Logger().Error("MsgFeePrepayDecorator", "Fee", fee)

		// payment := sdk.NewCoins(sdk.NewCoin("ujuno", fee))
		payment := sdk.NewCoins(sdk.NewCoin("ujuno", sdk.NewDec(500_000).RoundInt()))
		fpd.BankKeeper.MintCoins(ctx, "mint", payment)
		fpd.BankKeeper.SendCoinsFromModuleToAccount(ctx, "mint", feeTx.FeePayer(), payment)

		ctx.Logger().Error("MsgFeePrepayDecorator", "Minted & Sent to User", feeTx.FeePayer())
	}

	// TODOL: Thuis could give you funds and then make your next Tx successful.
	// fpd.BankKeeper.MintCoins(ctx, "bank", coinsAmt)
	// fpd.BankKeeper.SendCoinsFromModuleToAccount(ctx, "bank", "userAccount", coinsAmt)
	// auto feeprepay with the TxFee or somethuing here? as an option
	// set the Tx fee to be correct, set the accoiunt to be new and work, and then continue on

	ctx.Logger().Error("MsgFeePrepayDecorator", "Finished", true)

	return next(ctx, tx, simulate)
}

// TODO: Future: execute contract only.
// func hasInvalidExecuteMsgs(msgs []sdk.Msg) bool {
// 	for _, msg := range msgs {
// 		if _, ok := msg.(*wasmtypes.msgExecuteContract); ok {
// 			return true
// 		}
// 	}

// 	return false
// }
